# ********RoostGPT********
"""
Test generated by RoostGPT for test p-unit-azure-may23 using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=get_page_f50ab20ff6
ROOST_METHOD_SIG_HASH=get_page_60a1ba921e

Scenario 1: Test with valid medium article URL
Details:
  TestName: test_get_page_with_valid_medium_article
  Description: This test verifies that given a valid URL of a medium article, the function get_page will return the parsed HTML of the page.
Execution:
  Arrange: Set up a mock object for 'requests.get()' method that returns a successful response.
  Act: Call the function get_page with a valid medium article URL.
  Assert: Check if the returned value is a BeautifulSoup object and contains the expected HTML structure of a medium article.
Validation: 
  This is important to make sure that the function can correctly handle the main and expected use case, fetching and parsing a valid medium article page.

Scenario 2: Test with non-medium URL
Details:
  TestName: test_get_page_with_invalid_url
  Description: This test verifies that if provided with a URL that doesn't belong to Medium, the function get_page throws the appropriate error.
Execution:
  Arrange: No arrangement needed.
  Act: Call the function get_page with a non-medium URL (i.e a URL not starting with 'https://medium.com/').
  Assert: Check if the function call raises SystemExit.
Validation: 
  This is important to make sure that the function correctly validates input URLs, rejecting invalid or non-Medium URLs.

Scenario 3: Test with non-reachable medium article URL
Details:
  TestName: test_get_page_with_non_reachable_medium_article
  Description: This test verifies that if a valid medium URL is given, but it can't be reached (say, due to network issues), the function raises an appropriate error.
Execution:
  Arrange: Set up a mock object for 'requests.get()' method that returns a failed response.
  Act: Call the function get_page with a medium article URL.
  Assert: Check if the function call raises an error due to 'raise_for_status()' method from response.
Validation: 
  This is important to make sure that the function handles network or server errors gracefully, throwing an error if necessary.

Scenario 4: Test with non-HTML page URL (Edge case)
Details:
  TestName: test_get_page_with_non_html_url
  Description: This test verifies that if provided with a URL that leads to a non-HTML page, the function get_page returns none or throws an error.
Execution:
  Arrange: Set up a mock object for 'requests.get()' method that returns a valid response, but the response content is not HTML.
  Act: Call the function get_page with a URL that is not an HTML page.
  Assert: Check if the returned value is None or if the function call raises an error.
Validation: 
  This is important to make sure that the function appropriately handles edge cases and throws an error when an unsupported page type is provided.

Scenario 5: Test when user doesn't provide URL within timeout
Details:
  TestName: test_get_page_with_timeout_url
  Description: This test verifies that if the user doesn't provide the URL within the timeout, it should take the default URL.
Execution:
  Arrange: Use pytest's monkeypatch to simulate timedinput behavior.
  Act: Call the function get_page without user input within 5 seconds.
  Assert: Check if the being called URL is the default URL.
Validation: 
  This is important to make sure that the function correctly handles user input timeout scenario by using the default URL.
"""

# ********RoostGPT********
import pytest
import requests
import re
from bs4 import BeautifulSoup
from unittest.mock import Mock, patch
from scraping_medium import get_page

class Test_GetPage:

    @patch('requests.get')
    def test_get_page_with_valid_medium_article(self, mock_get):
        mock_res = Mock()
        mock_res.status_code = 200
        mock_res.text = '<html><body></body></html>'
        mock_res.raise_for_status = Mock()
        mock_get.return_value = mock_res
        
        with patch('timedinput.timedinput', return_value='https://medium.com/article'):
            soup = get_page()
        assert isinstance(soup, BeautifulSoup)
        assert soup.find('body') is not None

    def test_get_page_with_invalid_url(self):
        with pytest.raises(SystemExit):
            with patch('timedinput.timedinput', return_value='https://notmedium.com/article'):
                get_page()

    @patch('requests.get')
    def test_get_page_with_non_reachable_medium_article(self, mock_get):
        mock_res = Mock()
        mock_res.status_code = 404
        mock_res.raise_for_status = Mock(side_effect=requests.exceptions.HTTPError())
        mock_get.return_value = mock_res
        with patch('timedinput.timedinput', return_value='https://medium.com/article'):
            with pytest.raises(requests.exceptions.HTTPError):
                get_page()

    @patch('requests.get')
    def test_get_page_with_non_html_url(self, mock_get):
        mock_res = Mock()
        mock_res.status_code = 200
        mock_res.text = 'not html'
        mock_res.raise_for_status = Mock()
        mock_get.return_value = mock_res
        with patch('timedinput.timedinput', return_value='https://medium.com/article'):
            soup = get_page()
        assert soup is None or soup.find('body') is None

    def test_get_page_with_timeout_url(self, monkeypatch):
        timeout_mocker = Mock(return_value="https://medium.com/code-for-cause/open-source-organizations-that-use-python-3b052224afd9")
        monkeypatch.setattr('timedinput.timedinput', timeout_mocker)
        get_page()
        timeout_mocker.assert_called_once()
