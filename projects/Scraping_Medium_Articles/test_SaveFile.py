# ********RoostGPT********
"""
Test generated by RoostGPT for test p-unit-azure-may23 using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=save_file_d20d8bf70f
ROOST_METHOD_SIG_HASH=save_file_43f5757e60

Scenario 1: Test if the function successfully creates the directory if it does not exist.
Details:
  TestName: test_directory_creation_if_not_exists
  Description: This test will verify if the "scraped_articles" directory is created by the function if it does not exist before the function execution.
Execution:
  Arrange: Remove the 'scraped_articles' directory if it exists.
  Act: Run the save_file() function, passing a randomized filename and random text as content.
  Assert: Check that the directory 'scraped_articles' exists.
Validation:
  The creation of the directory is a part of the function's functionalities. The function needs to ensure data is stored in the correct location. 

Scenario 2: Test if the function returns the correct message.
Details:
  TestName: test_correct_message_return
  Description: This test will verify if the function returns the correct message after successfully saving the file.
Execution:
  Arrange: Prepare a file with random text content.
  Act: Run the save_file() function and capture the printed output.
  Assert: Check that the expected filename is included in the printed output, and the message matches the pattern 'File saved in directory <filename>'.
Validation:
  Returning the correct confirmation message is essential in ensuring the user that the function has successfully executed and the file is saved.

Scenario 3: Test if the function successfully saves the file.
Details:
  TestName: test_file_saved_successfully
  Description: This test will verify if the content passed to the function is saved into the file correctly.
Execution:
  Arrange: Prepare a known text content.
  Act: Run the save_file() function, passing the prepared text as the content.
  Assert: Check that a file with the passed text content exists in './scraped_articles' directory.
Validation:
  The function needs to correctly save the file with the passed content in the correct location.

Scenario 4: Test if the function handles the situation when the passed title contains prohibited characters.
Details:
  TestName: test_file_save_with_prohibited_chars_in_title
  Description: This test will verify if the function can handle titles with prohibited characters correctly. It should replace the characters with underscore while saving the file.
Execution:
  Arrange: Prepare a title with prohibited characters and some content.
  Act: Run the save_file() function, passing the prepared title and content.
  Assert: Check that a file with the correct revised filename exists in './scraped_articles' directory.
Validation:
  It is crucial to test this because certain characters are prohibited in filenames. The function should be able to deal with such situations efficiently.

Scenario 5: Test if function behaves correctly when the same title is passed multiple times.
Details:
  TestName: test_file_save_with_duplicate_titles
  Description: This test will verify how the function behaves when the same title is passed multiple times. It should overwrite the existing file.
Execution:
  Arrange: Prepare a title and some content and run the save_file() function with it once.
  Act: Run the save_file() function again with the same title and different content.
  Assert: Check that the file's content corresponds to the latter run, meaning the original file was overwritten.
Validation:
  The method is supposed to overwrite the file if the passed title is the same. Testing this ensures the function adheres to the required logic and functionality.

"""

# ********RoostGPT********
import os
import random
import string
import re
import shutil  # to handle directory removal properly
import pytest
from scraping_medium import save_file  # importing save_file valid path

# Registering custom pytest marks
def pytest_configure(config):
    config.addinivalue_line(
       "markers", "smoke: mark test as smoke test"
    )
    config.addinivalue_line(
        "markers", "regression: mark test as regression test"
    )
    config.addinivalue_line(
       "markers", "negative: mark test as negative test"
    )
    config.addinivalue_line(
        "markers", "valid: mark test as valid test"
    )
    config.addinivalue_line(
       "markers", "invalid: mark test as invalid test"
    )

class Test_SaveFile:
    @pytest.mark.smoke
    @pytest.mark.regression
    def test_directory_creation_if_not_exists(self):
        if os.path.exists('./scraped_articles'):
            shutil.rmtree('./scraped_articles')  # replace os.rmdir with shutil.rmtree for non-empty directories
        fileName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))
        content = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        save_file(content, fileName)  # correctly calling save_file with two arguments
        assert os.path.exists('./scraped_articles') == True  # "== True" can be omitted, included for clarity

    @pytest.mark.smoke
    @pytest.mark.negative
    def test_correct_message_return(self, capsys):
        fileName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))
        content = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        save_file(content, fileName)  # correctly calling save_file with two arguments
        captured = capsys.readouterr()
        assert captured.out == f'File saved in directory ./scraped_articles/{fileName}\n'

    @pytest.mark.smoke
    @pytest.mark.valid
    def test_file_saved_successfully(self):
        fileName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))
        content = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        save_file(content, fileName)  # correctly calling save_file with two arguments
        saved_content = open(f'./scraped_articles/{fileName}', 'r').read()
        assert saved_content == content

    @pytest.mark.regression
    @pytest.mark.invalid
    def test_file_save_with_prohibited_chars_in_title(self):
        fileName = 'test<*:>'
        expectedFileName = 'test____'
        content = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        save_file(content, fileName)  # correctly calling save_file with two arguments
        isFile = os.path.isfile(f'./scraped_articles/{expectedFileName}')
        assert isFile

    @pytest.mark.regression
    @pytest.mark.negative
    def test_file_save_with_duplicate_titles(self):
        fileName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))
        content1 = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        content2 = ''.join(random.choices(string.ascii_uppercase + string.digits, k=20))
        save_file(content1, fileName)  # correctly calling save_file with two arguments
        save_file(content2, fileName)  # correctly calling save_file with two arguments
        final_content = open(f'./scraped_articles/{fileName}', 'r').read()
        assert final_content == content2
